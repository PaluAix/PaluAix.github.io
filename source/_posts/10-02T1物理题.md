---
title: 10.02T1物理题
date: 2023-10-02 06:06:35
abbrlink: 3
categories: 动态规划
---

# 题目描述

物理课上，Enos正在做电学实验。Enos有一排灯座，总共可以接M个小灯泡。他还有N种小灯泡，每种小灯泡标有额定功率Pi，不同的小灯泡额定功率不同。为了使接通电源后灯座上的灯泡由暗到亮变化，要求小灯泡要按额定功率从小到大接。为避免接通电源后发光序列过于单调，规定不能有超过ai只连续的第i种小灯泡。不过Enos发现，在灯座上已经固定了一些小灯泡，它们无法被取下来。现在 Enos想知道，在电源接通下一共能有多少种不同的发光序列?可以不用某种小灯泡，但总共接入的小灯泡数必须恰为M。

# 格式

## 输入

第一行两个正整数N,M，分别表示小灯泡的个数和灯座上的接口数。接下来N行，每行两个正整数Pi,ai，含义如上描述。 接下来一行个M整数bi，如果bi为0表示第i个接口没有小灯泡，否则表示第i个接口已经固定有一只第bi种的小灯泡。

## 输出

一行一个整数表示不同的发光序列数。由于答案可能很大，你只需要输出答案除以1 000 000 007的余数即可。如果没有一种可行的方案，输出一行-1。

# 样例

## 输入数据 1

```input
2 4
40 3
60 2
0 0 1 0
```

## 输出数据 1

```output
1
```

# 数据范围与约定

对于 20% 的数据，N,M,ai≤ 10;

对于 50% 的数据，N，M,ai ≤ 20;

对于 100% 的数据，0<N,M,ai<100 ,0<Pi<=10 000 , 0<=bi<=N;

均匀分布着 20% 的数据，bi= 0。

# 题解

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n, m, b[105], vis[105];
const int mod = 1000000007;
inline int read() {
  char c = getchar();
  int x = 0, f = 1;
  while (c < '0' || c > '9') {
    if (c == '-') f = -1;
    c = getchar();
  }
  while (c >= '0' && c <= '9') {
    x = x * 10 + c - '0';
    c = getchar();
  }
  return x * f;
}
struct node {
  int power, max, flag;
} light[105];
bool cmp(node a, node b) { return a.power < b.power; }
signed main() {
  // freopen("physics.in", "r", stdin);
  // freopen("physics.out", "w", stdout);
  n = read(), m = read();
  for (int i = 1; i <= n; i++) {
    light[i].power = read(), light[i].max = read();
    light[i].flag = i;
  }
  for (int i = 1; i <= m; i++) b[i] = read();
  sort(light + 1, light + n + 1, cmp);
  vis[0] = 1;
  for (int i = 1; i <= n; i++) {
    for (int j = m - 1; j >= 0; j--)
      if (vis[j]) {
        for (int k = 1; k <= light[i].max; k++) {
          if (j + k > m) break;
          if (b[j + k] && b[j + k] != light[i].flag) break;
          vis[j + k] += vis[j];
          vis[j + k] = vis[j + k] % mod;
        }
      }
  }
  if (vis[m] == 0)
    printf("-1");
  else
    printf("%lld", vis[m]);
  return 0;
}
```