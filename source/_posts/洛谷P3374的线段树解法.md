---
title: 洛谷P3374的线段树解法
date: 2023-10-01 15:30:20
abbrlink: 2
categories: 数据结构
---
# P3374

## 题目描述

如题，已知一个数列，你需要进行下面两种操作：

- 将某一个数加上 $x$

- 求出某区间每一个数的和

## 输入格式

第一行包含两个正整数 $n,m$，分别表示该数列数字的个数和操作的总个数。   

第二行包含 $n$ 个用空格分隔的整数，其中第 $i$ 个数字表示数列第 $i$ 项的初始值。

接下来 $m$ 行每行包含 $3$ 个整数，表示一个操作，具体如下：

- `1 x k`  含义：将第 $x$ 个数加上 $k$

- `2 x y`  含义：输出区间 $[x,y]$ 内每个数的和

## 输出格式

输出包含若干行整数，即为所有操作 $2$ 的结果。

## 样例 #1

### 样例输入 #1

```
5 5
1 5 4 2 3
1 1 3
2 2 5
1 3 -1
1 4 2
2 1 4
```

### 样例输出 #1

```
14
16
```

## 提示

【数据范围】

对于 $30\%$ 的数据，$1 \le n \le 8$，$1\le m \le 10$；   
对于 $70\%$ 的数据，$1\le n,m \le 10^4$；   
对于 $100\%$ 的数据，$1\le n,m \le 5\times 10^5$。

数据保证对于任意时刻，$a$ 的任意子区间（包括长度为 $1$ 和 $n$ 的子区间）和均在 $[-2^{31}, 2^{31})$ 范围内。


样例说明：

 ![](https://cdn.luogu.com.cn/upload/pic/2256.png) 

故输出结果14、16

# 题解

**很明显，这是一道树状数组的模板题，但由于某神奇原因无法AC，故使用线段树来解。**

AC代码：

```cpp
#include <bits/stdc++.h>
#define int long long
#define LC pos * 2
#define RC pos * 2 + 1
using namespace std;
const int N = 5e5+5;
inline int read()
{
    char c = getchar();
    int x = 0, f = 1;
    while (c < '0' || c > '9')
    {
        if (c == '-')
            f = -1;
        c = getchar();
    }
    while (c >= '0' && c <= '9')
    {
        x = x * 10 + c - '0';
        c = getchar();
    }
    return x * f;
}
struct node
{
    int left, right, val;
} tree[N * 4];
void build(int pos, int left, int right)
{
    tree[pos].left = left;
    tree[pos].right = right;
    if (left == right)
    {
        tree[pos].val = read();
        return;
    }
    int mid = (left + right) / 2;
    build(LC, left, mid);
    build(RC, mid + 1, right);
    tree[pos].val = tree[LC].val + tree[RC].val;
}
void point_add(int pos, int x, int v)
{
    int left = tree[pos].left, right = tree[pos].right;
    if (left == right)
    {
        tree[pos].val += v;
        return;
    }
    int mid = (left + right) / 2;
    if (x <= mid)
        point_add(LC, x, v);
    else
        point_add(RC, x, v);
    tree[pos].val = tree[LC].val + tree[RC].val;
}
int ask(int pos, int left, int right)
{
    if (tree[pos].left >= left && tree[pos].right <= right)
        return tree[pos].val;
    int mid = (tree[pos].left + tree[pos].right) / 2;
    int ans = 0;
    if (left <= mid)
        ans += ask(LC, left, right);
    if (right > mid)
        ans += ask(RC, left, right);
    return ans;
}
signed main()
{
    int n = read(), m = read();
    build(1, 1, n);
    for (int i = 1; i <= m; i++)
    {
        int k = read(), a = read(), b = read();
        if (k == 1)
            point_add(1, a, b);
        else
            printf("%lld\n", ask(1, a, b));
    }

    system("pause");
    return 0;
}
```

![AC](https://cdn.luogu.com.cn/upload/image_hosting/bvm7mvcf.png)
