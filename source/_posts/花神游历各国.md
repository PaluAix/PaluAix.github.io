---
title: 花神游历各国
date: 2023-10-04 11:41:52
abbrlink: 7
categories: 数据结构
---

# 花神游历各国

## 题目描述

花神喜欢步行游历各国，顺便虐爆各地竞赛花神有一条游览路线，它是线型的，也就是说，所有游历国家呈一条线的形状排列，花神对每个国家都有一个喜欢程度（当然花神并不一定喜欢所有国家），每一次旅行中，花神会选择一条旅游路线，它在那一串国家中是连续的一段，这次旅行带来的开心值是这些国家的喜欢度的总和当然花神对这些国家的喜欢程度并不是恒定的，有时会突然对某些国家产生反感，使他对这些国家的喜欢度 $delta$ 变为 $\sqrt{delta}$，也就是开根号（可能是花神虐爆了那些国家的 OI，从而感到乏味），现在给出花神每次的旅行路线，以及开心度的变化，请求出花神每次旅行的开心值。

## 输入格式

第一行是一个整数 $N$ 表示有 $N$ 个国家。  
第二行有 $N$ 个空格隔开的整数，表示每个国家的初始喜欢度  $data_i$。  
第三行是一个整数 $M$ 表示有 $M$ 条信息要处理。  
第四行到最后,每行 $3$ 个整数，$x$，$l$，$r$，$ ( l \le r ) $。当 $x=1$ 时询问游历国家 $l$ 到 $r$ 的开心值总和，也就是 $\sum_{i=l}^{r} data_i$；当 $x=2$ 是国家 $l$ 到 $r$ 中每个国家的喜欢度 $delta = \sqrt{delta}$。  
注：建议使用sqrt函数，且向下取整。

## 输出格式

每次 $x=1$ 时，每行一个整数，表示这次旅行的开心度。

## 样例 #1

### 样例输入 #1

```
4
1 100 5 5
5
1 1 2
2 1 2
1 1 2
2 2 3
1 1 4
```

### 样例输出 #1

```
101
11
11
```

## 提示

对于 $100\%$ 的数据：$n \le 100000$，$m \le 200000$，$data_i$ 非负且小于 $10^9$。

# 题解

> 线段树单点修改变式

```cpp
#include <bits/stdc++.h>
#define LC p << 1
#define RC p << 1 | 1
#define int long long
using namespace std;
const int N = 1e6 + 5;
//const int N = 1e5 + 5; 艹，这数据绝对有问题,1e5过不去1e6就能了，题目描述不是是n<=10^5吗？？？
inline int IN() {
  char c = getchar();
  int x = 0, f = 1;
  while (c < '0' || c > '9') {
    if (c == '-') f = -1;
    c = getchar();
  }
  while (c >= '0' && c <= '9') {
    x = x * 10 + c - '0';
    c = getchar();
  }
  return x * f;
}
struct tree25 {
  int val, l, r;
} t[N * 4];
int ma[N];
void PushUp(int p) {
  t[p].val = t[LC].val + t[RC].val;
  ma[p] = max(ma[LC], ma[RC]);
  return;
}
void Build(int p, int l, int r) {
  if (l == r) {
    t[p].val = ma[p] = IN();
    return;
  }
  int mid = l + r >> 1;
  Build(LC, l, mid);
  Build(RC, mid + 1, r);
  PushUp(p);
}
void Update(int p, int l, int r, int x, int y) {
  if (ma[p] == 1 || ma[p] == 0) return;
  if (l == r) {
    ma[p] = t[p].val = sqrt(t[p].val);
    return;
  }
  int mid = l + r >> 1;
  if (x <= mid) Update(LC, l, mid, x, y);
  if (mid < y) Update(RC, mid + 1, r, x, y);
  PushUp(p);
}
int Ask(int p, int l, int r, int x, int y) {
  if (x <= l && r <= y) return t[p].val;
  int mid = l + r >> 1;
  int res = 0;
  if (x <= mid) res += Ask(LC, l, mid, x, y);
  if (y > mid) res += Ask(RC, mid + 1, r, x, y);
  return res;
}
signed main() {
  int n = IN();
  Build(1, 1, n);
  int q = IN();
  for (int i = 1; i <= q; i++) {
    int op = IN(), a = IN(), b = IN();
    if (op == 1)
      cout << Ask(1, 1, n, a, b) << endl;
    else
      Update(1, 1, n, a, b);
  }
  system("pause");
  return 0;
}
```

